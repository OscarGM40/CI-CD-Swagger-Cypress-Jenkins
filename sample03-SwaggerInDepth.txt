							SWAGGER IN-DEPTH TUTORIAL

Source: https://www.youtube.com/watch?v=EnMQm365t_s

Empiezo instalando swagger-ui-express,el propio express y yamljs.Fijate que este dev de momento no instala swagger-jsdoc.
NOTA:recuerda que puedes dejar un archivo request.http en cada proyecto con comentarios y las peticiones .

Al no instalar swagger-jsdo lo que va a hacer es cargar el archivo con esta librería:
const express = require("express");
const swaggerUI = require("swagger-ui-express");

const YAML = require("yamljs");
const swaggerJsDocs = YAML.load("./api.yaml");

Fijate que al usar el yaml ya no necesito pasarle el objeto SwaggerInitialSpecs coo en el proyecto 2 con la version,la api,los servers,....Desde luego es un mejor aproach para un proyecto medio-grande,incluso necesario seguramente:

app.use( "/api-docs", swaggerUI.serve, swaggerUI.setup(swaggerJsDocs));
* ya no es  swaggerUi.setup( swaggerJsDoc(swaggerInitialSpecs) )); pues lo voy a definir todo en el yaml.Perfecto.

Lógicamente tendré que crear este file:
const swaggerJsDocs = YAML.load("./api.yaml");

NOTA:nodemon por defecto sólo busca por cambios en archivos .js | mjs | json,pero no buscará por cambios en .yamls.Para que busque por cambios en este tipo de extensión creamos el file nodemon.json(que lo configura) en la raíz:

{
  "ext":".js,.jsx,.ts,.tsx,.json,.yml,.yaml"
}
Recuerda que es nodemon.json y tengo que ver el icono cambiado:
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,jsx,ts,tsx,json,yml,yaml <- ya puedo ver que mira por más extensiones.Genial.

Importante: fijate que en un yaml puedo usar igual que en un .env comillas si quiero y si no quiero también será un String:
Esto:  summary: "Returns a String" y  summary: Returns a String es lo mismo.

Fijate que a la hora de documentar un endpoint puedo documentar los statusCode y describirlos,además de especificar el tipo de dato que encontrará el usuario.Amazing:
paths:
  /string:
    get:
      summary: "Returns a String"
      description: "Returns a String"
      responses:
        200:
          description: "Success.You will get the content"
          content:
            application/json:
              schema:
                type: string
				example: "like this string"
        400:
          description: "Bad Request.You will get the error"
		  content:
            text/html:

Realmente puedo especificar muchísimo lo que hace cada endpoint.Siempre se especifica el tipo de la respuesta,como acabo de hacer con la propiedad schema.Incluso se le puede dar un ejemplo usando la prop schema.example

Veamos ahora como documentar este endpoint que devolverá un object:
app.get("/user",(req, res) => {
  res.send({
    id:1,
    name: "John",
    lastName: "Doe",
    age: 30
  });
})
NOTA: la propiedad tags es indispensable también.

Realmente es igual de sencillo,salvo que que para darle un example es un poco más complejo(usaremos la propiedad schema.properties):
  # returns an Object
  /user:
    get:
      tags:
        - clientes
      summary: "returns an Object"
      description: "Returns a single user"
      responses:
        200:
          description: "Success.User will be shown"
          content:
            application/json:
              schema:
                type: object
                properties:
                  name:
                    type: string
                    example: "Jane"
                  email:
                    type: string
                    example: "jane@example.com"

Esto mostrará:
{
  "name":"Jane",
  "email":"jane@example.com"
} Genial

Veamos ahora lo mismo retornando un arreglo en vez de un object:
  # returns an Array
  /users:
    get:
      tags:
        - clientes
      summary: "Returns a List of Users"
      description: "Returns an array of objects"
      responses:
        200:
          description: "Success.Array is shown"
          content:
            application/json:
              schema:
                type: array
                items:
                  type: object
                  properties:
                    name:
                      type: string
                      example: "Jane"
                    email:
                      type: string
                      example: "jane@example.com"

Realmente es igual,salvo que deberé usar schema.items en vez de schema.properties,ya que es un arreglo de items y no de properties(properties para objects).

En cuanto a mandar parámetros por la URL hay que usar {} y especificar de donde vienen(ya que pueden venir del path o la query):
  /users/{userId}:
    get:
      tags:
        - clientes
      summary: "Returns a single user by ID"
      description: "Returns a single user given an ID"
      parameters:
        - in: path 
          name: userId
          description: "User's ID"
          required: true
          schema:
            type: integer

Ese parameters.in probablemente cambie si van por la query.Ojo.Fijate que parameters.name es imprescindible que coincida con el nombre del :param.
Bien,veamos como documentar un POST:
  # sending a body
  /create:
    post:
      tags:
        - clientes
      summary: "Create a User"
      description: "Create a user given a Body"
      requestBody:
        description: "User's information"
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                name:
                  type: string
                  example: "Jane"
                email:
                  type: string
                  example: "johndoe@gmail.com"
                age:
                  type: integer
                  example: 22
Cabe reseñar el uso de requestBody,y que en versiones anteriores era parameters.in = body y se usaba consumes y produces en vez de content: application/json
Podria devolver un string como response,etc.
Fijate que este endpoint ya obliga al server express a interpretar json en el body,luego necesitaré configurarlo,como siempre.

Minuto 47

